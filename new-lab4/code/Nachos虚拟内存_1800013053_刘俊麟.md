# Nachos实习报告：线程调度

<p align=right>
刘俊麟
1800013053
</p>

[toc]

## 1 任务完成情况

- Exercise 1 : Y
- Exercise 2 : Y
- Exercise 3 : Y
- Exercise 4 : Y
- Exercise 5 : Y
- Exercise 6 : Y
- Exercise 7 : Y
- Challenge 1 : Y
- Challenge 2 : Y

## 2 具体Exercise完成情况

### 2.1 Exercise 1 源代码阅读
> 阅读 code/userprog/progtest.cc，着重理解 Nachos 执行用户程序的过程，以及该过程中与内存管理相关的要点。
>
> 阅读 code/machine 目录下的 machine.h(cc)，translate.h(cc) 文件和 code/userprog 目录下的 exception.h(cc)，理解当前 Nachos 系统所采用的 TLB 机制和地址转换机制。

#### 执行用户程序的过程

`code/userprog/progtest.cc` 中包含执行用户程序的相关模块。

其中的 `StartProcess()` 函数主要负责了用户程序执行的相关工作，它接受一个文件名后打开这个可执行文件，之后使用 `AddrSpace` 类的构造函数为其分配地址空间，之后对地址空间进行相应初始化（设置寄存器初始值、载入页表寄存器等）后调用 `machine->Run()` 执行相应用户程序。

关于类 `AddrSpace` ，其定义及相关操作位于 `code/userprog/addrspace.h` 和 `code/userprog/addrspace.cc` 中，其构造函数首先将文件头中内容加载到 `NoffHeader` 的结构体中，该结构体定义了 Nachos 目标代码格式；之后，其计算用户程序所需要空间大小；之后建立建立从用户程序地址到物理地址的翻译机制，目前使用的机制是完全的一对一的，该页表定义在 `AddrSpace` 类中。再然后其初始化物理内存空间，并将程序的 code 段和 initData 段拷贝到内存中。

`proctest.cc` 中还有一个函数 `ConsoleTest()` ，其用于控制台的输入输出测试。

#### TLB 机制和地址转换机制

`code/machine/machine.h(cc)` 中定义了各种 Nachos 硬件模拟的各种宏、结构、函数的实现。其中定义了内存大小，TLB 大小，物理页的个数和页的大小等信息，以及定义了一些异常的种类及其编号。也包括了各种指令模拟、寄存器读写、内存读写的方法。注意到在 `machine.cc` 中有一处判断了宏 `USE_TLB` ，说明 Nachos 现在的机制默认没有使用 TLB 。

在 `code/machine/translate.h(cc)` 中对地址转换机制进行了实现。

其中 `translate.h` 文件中定义了页表项和 TLB 表项类 `TranslationEntry` ，包含虚拟页号、物理页号和有效、只读等属性，负责了虚拟内存到物理内存的转换工作。

`translate.cc` 文件中实现了 Nachos 地址转换函数 `Translate()` ，将虚拟地址转换为物理地址，在出错时抛出相关错误，其中我们也能看到 Nachos 现在的处理机制不支持页表和 TLB 的共存，需要我们之后的处理。此外，该文件中也实现了读写内存的相关函数。

而 `code/userprog/exception.cc` 文件中定义了所有异常的处理函数 `ExceptionHandler()`，缺页异常和 TLB MISS 等错误的处理都在该函数中进行。此外，系统调用也在该函数中被处理。

### 2.2 Exercise 2 TLB MISS 异常处理
> 修改 code/userprog 目录下 exception.cc 中的 ExceptionHandler 函数，使得 Nachos 系统可以对 TLB 异常进行处理(TLB 异常时，Nachos 系统会抛出 PageFaultException ，详见 code/machine/machine.cc)。

首先，为了使用 TLB ，我们先在 `code/userprog/Makefile` 中添加宏定义 `USE_TLB`
```
DEFINES = -DUSER_PROGRAM -DFILESYS_NEEDED -DFILESYS_STUB -DUSE_TLB
```

之后我们注释掉 `translate.cc` 中的  `ASSERT(tlb == NULL || pageTable == NULL);` ，使得页表和 TLB 能够同时使用。这时我们能够发现，TLB MISS 时抛出 PageFaultException 异常，故我们需要在 `exception.cc` 中的 `ExceptionHandler()` 处理函数中增加对于该异常的处理。具体的 `TLBMissHandler()` ，即具体的替换算法将在 Exercise 3 中实现。

```cpp
if (which == PageFaultException) {
    if (machine->tlb == NULL) {
      printf("Page table page fault.\n");
      ASSERT(FALSE);
    } else {
      printf("TLB miss!\n");
      int BadVAddr = machine->ReadRegister(BadVAddrReg);
      TLBMissHandler(BadVAddr);
    }
    return;
  }
```

### 2.3 Exercise 3 置换算法
> 为 TLB 机制实现至少两种置换算法，通过比较不同算法的置换次数可比较算法的优劣。

在实现替换算法之前，需要首先完善 `TLBMissHandler()` 函数，将 TLB 中缺失的项从页表中拿出，再调用具体的替换算法：

```cpp
void TLBMissHandler(int BadVAddr) {
  unsigned int vpn = (unsigned) BadVAddr / PageSize;
  TranslationEntry page = machine->pageTable[vpn];
  if (!page.valid) {
    printf("True page table page fault happens!\n");
    ASSERT(FALSE);
  }
  FIFOReplace(page); // some replace algorithm
}
```

替换算法实现方面，我实现了 LRU、FIFO 和随机替换三种算法。

由于在测试时，我发现 `code/test/` 中的测试文件都不适合用于评测 TLB 的 miss rate，故我添加了一个进行数组遍历的测试代码 `simple.c` ，并将其添加到了 Makefile 中

#### FIFO

首先，我对于较为简单的 FIFO 算法进行了实现，首先尝试是否能够找到空（非有效）的 TLB 项，若有则替换，否则将所有的 TLB 项整体前移，新进入项从数组末尾进入，这样就能够让先进入 TLB 的项先被换出。

```cpp
// FIFO Replace
void FIFOReplace(TranslationEntry page) {
  printf("Using FIFO Replace Algorithm!\n");
  int replaceIdx = -1;
  for (int i = 0; i < TLBSize; i++) {
    if (machine->tlb[i].valid == FALSE) {
      replaceIdx = i;
      break;
    }
  }
  if (replaceIdx == -1) { // FIFO
    for (int i = 1; i < TLBSize; i++) {
      machine->tlb[i - 1] = machine->tlb[i];
    }
    replaceIdx = TLBSize - 1;
  }
  machine->tlb[replaceIdx] = page;
}
```



## 3 遇到的困难以及收获


## 4 对课程或Lab的意见和建议

无。

## 5 参考文献

- 《操作系统》课程 PPT