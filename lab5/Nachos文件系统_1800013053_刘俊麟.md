# Nachos实习报告：文件系统

<p align=right>
刘俊麟
1800013053
</p>

[toc]

## 1 任务完成情况

- Exercise 1 : Y
- Exercise 2 : Y
- Exercise 3 : Y
- Exercise 4 : Y
- Exercise 5 : Y
- Exercise 6 : Y
- Exercise 7 : Y
- Challenge 1 : Y
- Challenge 2 : Y

## 2 具体Exercise完成情况

### 2.1 Exercise 1 源代码阅读
> 阅读 Nachos 源代码中与文件系统相关的代码，理解 Nachos 文件系统的工作原理。
> 
> code/filesys/filesys.h 和 code/filesys/filesys.cc
> 
> code/filesys/filehdr.h 和 code/filesys/filehdr.cc
> 
> code/filesys/directory.h 和 code/filesys/directory.cc
> 
> code/filesys/openfile.h 和 code/filesys/openfile.cc 
> 
> code/userprog/bitmap.h 和 code/userprog/bitmap.cc

code/filesys/filesys.h 和 filesys.cc : 实现了 Nachos 的文件系统类 `FileSystem` 。值得注意的是，代码中定义了两个文件系统类，其中宏 `FILESYS_STUB` 定义的是基于本机上的 Unix 文件系统，以让 Nachos 的文件系统相关功能在其他工作之前能暂时被使用。另一个文件系统类就是 Nachos 本身的文件系统类，成员变量有 `freeMapFile` ，用于记录空闲磁盘块的 Bimap，被存储为文件类，以及 `directoryFile` ，用于记录根目录下的文件。其主要的成员函数有：

- `FileSystem(bool format)` : 构造函数，接受一个 bool 类型的参数 `format`，用于指示磁盘是否需要初始化，使用新的空闲磁盘块位图以及新的文件目录。
- `Create(char *name, int initialSize)` : 创建文件的函数，参数分别为文件名和其初始大小字节数（目前版本文件大小创建后就不能被改变）。创建时，首先确定文件是否已经存在，之后为文件头分配一个扇区，将文件名加入目录中，并为数据区分配扇区，最后将新的文件头写入磁盘，并将新的 Bitmap 和目录以文件形式写回磁盘。若创建途中出现错误则会返回 FALSE 。
- `Open(char *name)` : 根据文件名返回打开文件。通过目录文件查找目标文件头所在的扇区，再读取文件头，最终返回打开文件的指针，若未找到则会返回空指针。
- `Remove(char *name)` : 根据文件名删除文件。通过目录查找文件名，查找到存放文件头的扇区，读取文件头后删除，根据文件头释放数据区占据的磁盘块，从目录中删去文件名，最后更新目录和 `freeMap` ，并写回磁盘文件。
- `List()` : 列出根目录下所有文件名。
- `Print()` : 打印文件系统信息，包括空闲区表、目录内容和其文件头的相关信息。

code/filesys/filehdr.h 和 filehdr.cc : 实现了 Nachos 中的头文件类 `FileHeader` 。其中包含变量有：文件的字节数`numBytes` 、文件数据占用的磁盘块的个数 `numSectors` 和记录每个磁盘块位置的数组 `dataSectors` 。其成员函数定义了许多对于文件头的相关操作，主要包括：

- `Allocate(BitMap *bitMap, int fileSize)` : 根据传入的空闲位图指针和文件大小，为文件分配空闲磁盘块。其首先根据文件大小计算所需磁盘块数目，之后根据空间是否充足对其分配相应的磁盘块。
- `Deallocate(BitMap *freeMap)` 释放文件占据的磁盘块，并更新空闲位图。
- `FetchFrom(int sector)` : 从磁盘块中读出文件头的信息。
- `WriteBack(int sector)` : 将新的文件头信息写回磁盘。
- `ByteToSector(int offset)` : 返回距开头 offset 字节数所在的磁盘块的位置。
- `FileLength()` : 返回文件大小，即其占用字节数。
- `Print()` : 打印文件头信息和相关的文件信息。

code/filesys/directory.h 和 directory.cc : Nachos 的目录类 `Directory` 和目录表表项类 `DirectoryEntry` 。其中的目录表表项按照 <文件名, 该文件文件头所在扇区> 来存储。在 directory.h 中还定义了目前允许的文件名最长长度（目前是 9）。该类包含的主要操作有：

- `Directory(int size)` : 构造函数，根据传入的 size 对目录表进行初始化。其在文件系统类的构造函数中被调用，传入参数为宏 `NumDirEntries` ，说明目前文件系统文件数目有上限（目前为 10）
- `FetchFrom(OpenFile *file)` : 从磁盘中读取目录的相关信息
- `WriteBack(OpenFile *file)` : 将目前目录的相关信息写回磁盘文件
- `FindIndex(char *name)` : 根据文件名寻找相应的目录表位置，若未找到则返回 -1
- `Find(char *name)` : 利用了 `FindIndex()` 函数，从而可以根据文件名寻找相应的目标文件文件头所在扇区，若未找到则返回 -1
- `Add(char *name, int newSector)` : 将文件的文件名和文件头所在磁盘块添加到目录表中，如果添加成功则返回 TRUE ，若添加失败（目录已满或目录表中已有同名文件），则返回 FALSE
- `Remove(char *name)` : 从目录表中删除文件
- `List()` : 打印本目录的所有文件的文件名
- `Print()` : 打印本目录的所有文件的详细信息。

code/filesys/openfile.h 和 openfile.cc : Nachos 用于读写文件的打开文件类 `OpenFile` 。类似文件系统类， Nachos 中同样具有两个打开文件类，有一个基于本机的 Unix 文件系统。对于 Nachos 自己的打开文件类，其中包含指向文件头的指针 `hdr` 和当前所在的位置 `seekPosition` ，以距离文件开头的字节数表示。打开文件类包含的主要函数有：

- `OpenFile(int sector)` : 构造函数，根据给定的磁盘块从其中读取文件头，同时将 `seekPosition` 初始化为 0
- `SeekPosition(int position)` : 根据传入参数重新设定 `seekPosition`
- `ReadAt(char *into, int numBytes, int position)` : 从 `position` 位置开始读取 `numBytes` 个字节（若 `numBytes` 过大，则读到文件末尾），写入 `into` 指针的位置。其会检查 `numBytes` 是否不为正数或超过文件大小，接着计算起始和结束的磁盘块，调用磁盘的 `ReadSector()` 函数将磁盘相应位置的内容读入缓冲区中，再复制到目标位置，返回成功读取的字节数。
- `Read(char *into, int numBytes)` : 封装了 `ReadAt()` 函数，从当前位置读指定字节数到目标位置，同时更新当前位置；
- `WriteAt(char *from, int numBytes, int position)` : 类似 `ReadAt()` ，以 `from` 指针指向位置为源，向 `position` 位置写入 `numBytes` 个字节的数据。同样会先检查 `numBytes` 的合法性，接着计算起始和结束的磁盘块，设立缓冲区，检查要写的第一个和最后一个磁盘块是否对齐，若未对齐则读入缓冲区；再将 `from` 指向的内容复制到缓冲区，再调用磁盘的 `WriteSector()` 方法逐个将缓冲区内容写入磁盘块，删除缓冲区，最后返回成功写入的字节数。
- `Write(char *into, int numBytes)` : 类似 `Read()` ，同样封装了 `WrteAt()` ，在写之后更新当前位置。
- `Length()`：返回打开文件的字节数

code/userprog/bitmap.h 和 bitmap.cc : 位图数据结构的定义，包含寻找，清除等系列操作，在虚拟内存 Lab 中已经使用过，此处不再赘述。
### 2.2 Exercise 2 扩展文件属性 
> 增加文件描述信息，如“类型”、“创建时间”、“上次访问时间”、“上次修改时间”、“路径”等等。尝试突破文件名长度的限制。

首先，我们在目录项中添加并修改成员变量，包括：
- 添加 bool 型变量 `isDirectory` ，指示其是否是一个目录，若为 FALSE 则代表其是一个文件。
- 将文件名 `name`改为 char * 型，以突破长度限制
- 路径将放在 Exercise 4 多级目录中实现

```cpp
class DirectoryEntry {
public:
  bool inUse;                    // Is this directory entry in use?
  int sector;                    // Location on disk to find the
                                 //   FileHeader for this file
  // char name[FileNameMaxLen + 1]; // Text name for file, with +1 for
                                 // the trailing '\0'
  bool isDirectory;
  char *name;
};
```

之后，我们在文件头类中添加时间变量，分别指示文件的创建时间、上次访问时间和上次修改时间：
```cpp
  time_t createTime;          // Create time of the file
  time_t lastAccessTime;      // Last access time of the file
  time_t lastModifyTime;       // Last modify time of the file
```

我们再对于 `Directory` 类的 `Add()` 函数进行相应的修改，由于此时只有根目录，因此此处添加的全部为文件：
```cpp
bool Directory::Add(char *name, int newSector) {
  if (FindIndex(name) != -1)
    return FALSE;

  for (int i = 0; i < tableSize; i++)
    if (!table[i].inUse) {
      table[i].inUse = TRUE;
      table[i].name = name;
      table[i].isDirectory = FALSE;
      table[i].sector = newSector;
      return TRUE;
    }
  return FALSE; // no space.  Fix when we have extensible files.
}
```

而为了维护上面添加的时间变量，我们在 `FileHeader` 类的 `Allocate()` 函数中设置创建时间，并更新访问和修改时间。注意此处修改之后，由于添加了变量，所能存储的 `dataSectors` 块数也就相应减少。因此，我们修改 `NumDirect` 宏的定义。
```cpp
#define NumDirect ((SectorSize - 2 * sizeof(int) - 3 * sizeof(time_t)) / sizeof(int))
```

之后，我们在 `OpenFile` 类的 `Read()` 和 `Write()` 函数出分别更新相应文件的文件头的时间，但是需要注意的是，此处更新过后，需要将修改后的文件头进行一次写回操作，否则可能导致修改不起效，为了方便写回，我们在 `OpenFile` 中定义了变量 `hdrSector` ，指示文件头所在删去，并在构造函数中进行相关初始化。

```cpp
int OpenFile::Read(char *into, int numBytes) {
  int result = ReadAt(into, numBytes, seekPosition);
  seekPosition += result;
  hdr->lastAccessTime = time(NULL);
  hdr->WriteBack(hdrSector);
  return result;
}

int OpenFile::Write(char *into, int numBytes) {
  int result = WriteAt(into, numBytes, seekPosition);
  seekPosition += result;
  hdr->lastAccessTime = time(NULL);
  hdr->lastModifyTime = hdr->lastAccessTime;
  hdr->WriteBack(hdrSector);
  return result;
}
```

之后我们在 `FileHeader` 的 `Print()` 函数中增加对于相关事件的输出。最后我们对于修改进行相应测试。首先我们将文件大小修改为 50B ，并修改 `PerformanceTest()` 函数，使之不删除创建的文件。之后输入命令 `./nachos -f` 进行文件系统初始化，输入 `./nachos -t` 进行测试，发现可以创建文件、进行读写、输出文件属性等操作，符合我们的预期。

```
...
Name: TestFile, Sector: 5
FileHeader contents.  File size: 50.  File blocks: 6 
Create Time: Wed Dec 23 06:26:09 2020
 Last Access Time: Wed Dec 23 06:26:09 2020
 Last Modify Time:Wed Dec 23 06:26:09 2020
File contents:
12345678901234567890123456789012345678901234567890

...
```

### 2.3 Exercise 3 扩展文件长度 
> 改直接索引为间接索引，以突破文件长度不能超过 4KB 的限制。



### 2.4 Exercise 4 实现多级目录

### 2.5 Exercise 5 动态调整文件长度
> 对文件的创建操作和写入操作进行适当修改，以使其符合实习要求。

### 2.6 Exercise 6 源代码阅读
> a) 阅读 Nachos 源代码中与异步磁盘相关的代码，理解 Nachos 系统中异步访问模拟磁盘的工作原理。
>
> filesys/synchdisk.h 和 filesys/synchdisk.cc
> 
> b) 利用异步访问模拟磁盘的工作原理，在 Class Console 的基础上，实现 Class SynchConsole。
### 2.7 Exercise 7 
> 实现文件系统的同步互斥访问机制，达到如下效果:
>
> a) 一个文件可以同时被多个线程访问。且每个线程独自打开文件，独自拥有一个当前文件访问位置，彼此间不会互相干扰。
>
> b) 所有对文件系统的操作必须是原子操作和序列化的。例如，当一个线程正在修改一个文件，而另一个线程正在读取该文件的内容时，读线程要么读出修改过的文件，要么读出原来的文件，不存在不可预计的中间状态。
> 
> c) 当某一线程欲删除一个文件，而另外一些线程正在访问该文件时，需保证所有 线程关闭了这个文件，该文件才被删除。也就是说，只要还有一个线程打开了这个文件，该文件就不能真正地被删除。



### 2.8 Challenge 1 性能优化
> a) 例如，为了优化寻道时间和旋转延迟时间，可以将同一文件的数据块放置在磁盘同一磁道上。
> 
> b) 使用cache机制减少磁盘访问次数，例如延迟写和预读取。

### 2.9 Challenge 2 实现 pipe 机制
> 重定向 openfile 的输入输出方式，使得前一进程从控制台读入数据并输出至管道， 后一进程从管道读入数据并输出至控制台。

## 3 遇到的困难以及收获


## 4 对课程或Lab的意见和建议

无。

## 5 参考文献

- 《操作系统》课程 PPT