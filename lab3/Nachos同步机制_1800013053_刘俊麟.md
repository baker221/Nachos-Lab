# Nachos实习报告：线程调度

<p align=right>
刘俊麟
1800013053
</p>
[toc]

## 1 任务完成情况

|   任务   | Exercise 1 | Exercise 2 | Exercise 3 | Exercise 4 | Challenge 1 | Challenge 2 | Challenge 3 |
| :------: | :--------: | :--------: | :--------: | :--------: | :---------: | :---------: | :---------: |
| 完成情况 |     Y      |     Y      |     Y      |     Y      |             |             |             |

## 2 具体Exercise完成情况

### 2.1 Exercise 1 调研
> 调研 Linux 中实现的同步机制

### 2.2 Exercise 2 源代码阅读

在阅读代码之后，现总结其重点如下。

`code/threads/synch.h` 和 `code/threads/synch.cc` : 定义了信号量 (Semaphore) 、锁 (Lock) 和条件变量 (Condition) ，其中只有信号量具体实现了，锁和条件变量的实现需要我们之后完善。
- Semaphore : 包含了成员 `name` (用于调试)，`value` (当前信号量的值，信号量的定义保证了其一定非负)，`queue` (当前 P 操作的等待队列) 和两个函数。
  - `P()` : P 操作，若当前 `value` 为正，则将 `value` 值减 1 ，否则将当前进程插入等待队列 `queue` 中，并进入睡眠状态
  - `V()` : V 操作，唤醒等待队列的首个进程，并将 `value` 值加 1 ，以让其 P 操作能正确进行
  - 需要重点关注的是，阅读后我们能够发现， `P()` 和 `V()` 函数通过关中断操作来保证了自己的原子性
- Lock : 仅包含一个用于调试的成员 `name` 和一些仅声明但并未具体实现的函数（甚至其自身的构造函数和析构函数也还未完善）
  - `Acquire()` : 得到锁的操作，若锁此时被其他进程持有，则进入睡眠态，直至可以获取
  - `Release()` : 释放当前锁，并从等待锁的队列中唤醒进程
  - `isHeldByCurrentThread()` : 指示该锁是否被当前进程所持有
- Condition : 类似 Lock 的情况，仅包含用于调试的成员 `name` 和一些还未具体实现的函数，需要我们在之后自行完善。
  - `Wait()` : 首先将已得到的锁释放掉，之后将自己放入等待队列中，进入 Sleep 态，被唤醒后尝试重新取得锁
  - `Signal()` : 从等待队列中唤醒一个等待该条件变量的进程
  - `Broadcast()` : 唤醒等待队列中的所有进程

`code/threads/synchlist.h` 和 `code/threads/synchlist.cc` : 利用锁和条件变量实现了一个同步列表 (SynchList) 。其中包含了一个 `list` ，一把锁 `lock` 和一个指示当前 `list` 是否为空的条件变量 `listEmpty` 。

其成员函数和 `List` 类的基本相同，包含 `Append()` 、 `Remove()` 和 `Mapcar()` 函数，分别对 `list` 进行添加、删除和 map 操作。

但是和 `List` 中不同的是，此处的这几个函数进行了锁和条件变量的封装，能够保证进行这些操作时不会受到其他进程的干扰，且当 `list` 为空时会等待直到其中有元素。也就是说，同步列表是一个实现了同步和互斥功能的列表。

### 2.3 Exercise 3 实现锁和条件变量
> 可以使用 sleep 和 wakeup 两个原语操作 (注意屏蔽系统中断) ，也可以使用 Semaphore 作为唯一同步原语 (不必自己编写开关中断的代码) 。

首先，使用信号量 `Semaphore` 来尝试实现锁 `Lock` 。

只需要在 `Lock` 类中增加一个信号量成员 `truelock`，其值在构造函数中被初始化为 1 。并添加一个 `Thread` 指针，用于指示锁的持有进程。其余函数的具体实现只需要套用信号量中的接口，并稍作变通即可。

只是需要注意，在进行得到锁、释放锁等操作前，同样需要先将中断关闭。

还有一点需要注意的是，一个进程申请得到的锁不能被另一个进程释放，因此， `Release()` 函数中需要判断当前进程是不是锁的持有者。

```cpp
Lock::Lock(char *debugName)
    : name(debugName), truelock(new Semaphore("lock", 1)), owner(NULL) {}
Lock::~Lock() { delete truelock; }
void Lock::Acquire() {
  IntStatus oldLevel = interrupt->SetLevel(IntOff);
  truelock->P();
  owner = currentThread;
  (void)interrupt->SetLevel(oldLevel);
}
void Lock::Release() {
  IntStatus oldLevel = interrupt->SetLevel(IntOff);
  ASSERT(owner == currentThread);
  owner = NULL;
  truelock->V();
  (void)interrupt->SetLevel(oldLevel);
}
bool Lock::isHeldByCurrentThread() { return currentThread == owner; }
```

之后再实现条件变量。在其中添加 `List` 类的成员 `wait_queue` ，用于存放等待队列中的进程。其余各函数的具体实现同样根据其相应功能即可实现。关闭中断同样需要在此处实现。以及同样需要判断当前 `conditionLock` 的持有情况。

```cpp
Condition::Condition(char *debugName)
    : name(debugName), wait_queue(new List()) {}
Condition::~Condition() { delete wait_queue; }
void Condition::Wait(Lock *conditionLock) {
  IntStatus oldLevel = interrupt->SetLevel(IntOff);
  ASSERT(conditionLock->isHeldByCurrentThread());
  conditionLock->Release();
  wait_queue->Append(currentThread);
  currentThread->Sleep();
  conditionLock->Acquire();
  (void)interrupt->SetLevel(oldLevel);
}
void Condition::Signal(Lock *conditionLock) {
  IntStatus oldLevel = interrupt->SetLevel(IntOff);
  ASSERT(conditionLock->isHeldByCurrentThread());
  if (!wait_queue->IsEmpty()) {
    Thread *next = (Thread *)wait_queue->Remove();
    scheduler->ReadyToRun(next);
  }
  (void)interrupt->SetLevel(oldLevel);
}
void Condition::Broadcast(Lock *conditionLock) {
  IntStatus oldLevel = interrupt->SetLevel(IntOff);
  ASSERT(conditionLock->isHeldByCurrentThread());
  while (!wait_queue->IsEmpty()) {
    Signal(conditionLock);
  }
  (void)interrupt->SetLevel(oldLevel);
}
```

### 2.4 Exercise 4 实现同步互斥实例
> 基于 Nachos 中的信号量、锁和条件变量，采用两种方式实现同步和互斥机制应用(其中使用条件变量实现同步互斥机制为必选题目)。具体可选择“生产者-消费者问题”、“读者-写者问题”、“哲学家就餐问题”、“睡眠理发师问题”等。(也可选择其他经典的同步互斥问题)

啊这啊这啊这啊这

### 2.5 Challenge 1 实现 barrier
> 可以使用 Nachos 提供的同步互斥机制 (如条件变量) 来实现 barrier，使得当且仅当若干个线程同时到达某一点时方可继续执行。


## 3 遇到的困难以及收获


## 4 对课程或Lab的意见和建议


## 5 参考文献
