# Nachos实习报告：线程调度

<p align=right>
刘俊麟
1800013053
</p>
[toc]

## 1 任务完成情况

|   任务   | Exercise 1 | Exercise 2 | Exercise 3 | Challenge 1 |
| :------: | :--------: | :--------: | :--------: | :---------: |
| 完成情况 |     Y      |     Y      |     Y      |      Y      |

## 2 具体Exercise完成情况

### 2.1 Exercise 1 调研
> 调研 Linux 或 Windows 中采用的进程/线程调度算法。

我调研了Windows系统的


### 2.2 Exercise 2 源代码阅读

在阅读实习说明中给出的几个文件之后，现总结其中的重点如下：

`code/threads/scheduler.h` 和 `code/threads/scheduler.cc` ：定义了 `Scheduler` 类，作为Nachos中的线程调度器。

- `readyList` : 类的主要成员，是类维护的一个FIFO的队列，存储状态为 `Ready` 的线程。
- `ReadyToRun()` : 将进程状态设置为 `Ready` 并放入 `readyList` 中。
- `FindNextToRun()` : 取出 `readyList` 中最靠前的线程，准备使其上CPU。
- `Run()` : 将旧进程的堆栈等信息保存后，进行线程切换，将新线程的状态信息加载到CPU，运行新线程。实际的信息拷贝等工作由汇编代码 `code/threads/switch.s` 完成。
- 从这两个文件的代码中可以看出，现存的Nachos的调度策略只是简单从 `readyList` 中取出第一个就绪的线程，即FIFO。

`code/threads/switch.s` : CPU上进程切换的具体实现。首先保存了当前进程的状态，之后载入新进程的状态，然后切换到相应的栈空间，开始运行新线程。

`code/machine/timer.h` 和 `code/machine/timer.cc` : 使用一个 `Timer` 类用于模拟硬件的时间中断。其中 `TimerOfNextInterrupt()` 计算出下次中断的时间， `TimerExired()` 会利用其计算的时间，将中断插入等待处理中断队列之中，并调用相应的时钟中断处理函数。如果 `Timer` 类的 `randomize` 成员为 `true` ，则计算的时间会产生一定的随机偏移。

### 2.3 Exercise 3 线程调度算法扩展
> 扩展线程调度算法，实现基于优先级的抢占式调度算法。

首先，我们先在`thread.h` 中为 `Thread` 类增加private变量 `priority` ，并添加相应的入口函数 `setPriority()` 和 `getPriority()` ，并更改相应的构造函数，以让线程在被创建时就被赋予相应的优先级。这里指的注意的一点是， `priority` 数值越小的其优先级越高。

之后，修改 `scheduler.cc` 中的 `ReadyToRun()` 函数：
```cpp
void Scheduler::ReadyToRun(Thread *thread) {
  DEBUG('t', "Putting thread %s on ready list.\n", thread->getName());

  thread->setStatus(READY);
  readyList->SortedInsert((void *)thread, thread->getPriority());
}
```
将之前直接插入的 `Append()` 函数更改为依照 `priority` 数值递增的顺序插入（注意数值越小的优先级越大），即能够实现在 `readyList` 中最靠前的线程拥有最大的优先级。这就实现了基于优先级的调度算法。

之后实现“抢占式”，若存在优先级更高的线程则抢占当前线程。具体实现同样是在 `ReadyToRun()` 函数中，在插入线程后，检查插入的线程优先级是否比当前进程更高，若是，则对当前线程进行 `Yield()` 操作即可：
```cpp
  if (currentThread->getPriority() > thread->getPriority()) { // 数值高的优先级小
    currentThread->Yield();
  }
```
最后我们在 `threadtest.cc` 文件中增加相应的测试函数并进行测试。
```cpp
void ThreadPriorityTest() {
  DEBUG('t', "Entering ThreadPriorityTest");

  Thread *t1 = new Thread("forked thread 1", 1);
  Thread *t2 = new Thread("forked thread 2", 2);
  Thread *t3 = new Thread("forked thread 3", 3);
  Thread *t4 = new Thread("forked thread 4", 4);

  t4->Fork(newSimpleThread, (void *)4);
  t3->Fork(newSimpleThread, (void *)3);
  t2->Fork(newSimpleThread, (void *)2);
  t1->Fork(newSimpleThread, (void *)1);
  
  currentThread->Yield();
}
```
我们将创建的4个线程按照优先级从低到高的顺序分别执行 `newSimpleThread()` 函数（即原始的 `SimpleThread()` 函数删去 `Yield()` 的部分），可以发现优先级高的线程执行得更早而非按照代码中的顺序，这就实现了按照优先级调度的抢占式算法。

### 2.4 Challenge 1 线程调度算法扩展 时间片轮转算法
> 可实现“时间片轮转算法”、“多级队列反馈调度算法”，或将 Linux 或 Windows 采用的调度算法应用到 Nachos 上。

我尝试了实现时间片轮转算法。



## 3 遇到的困难以及收获
1. 一开始时 Exercise 3 只实现了基于优先级的算法，在思考后才明白只需在插入就绪队列时检查优先级即可实现抢占式的调度。
2. 在 Challenge 1 中实现时间片轮转算法时，忘记将 Exercise 3 中实现的基于优先级调度的抢占式算法的抢占部分给删去，这导致时间片轮转算法的行为并不符合预期。（不对？删去后仍然表现异常）

## 4 对课程或Lab的意见和建议
1. 该课程任务量过于庞大，deadline 过于紧密，希望能酌情考虑减轻。

## 5 参考文献

