# Nachos实习报告：线程调度

<p align=right>
刘俊麟
1800013053
</p>

[toc]

## 1 任务完成情况

- Exercise 1 : Y
- Exercise 2 : Y
- Exercise 3 : Y
- Exercise 4 : Y
- Exercise 5 : Y
- Exercise 6 : Y
- Exercise 7 : Y
- Challenge 1 : Y
- Challenge 2 : Y

## 2 具体Exercise完成情况

### 2.1 Exercise 1 源代码阅读
> 阅读 code/userprog/progtest.cc，着重理解 Nachos 执行用户程序的过程，以及该过程中与内存管理相关的要点。
>
> 阅读 code/machine 目录下的 machine.h(cc)，translate.h(cc) 文件和 code/userprog 目录下的 exception.h(cc)，理解当前 Nachos 系统所采用的 TLB 机制和地址转换机制。

#### 执行用户程序的过程

`code/userprog/progtest.cc` 中包含执行用户程序的相关模块。

其中的 `StartProcess()` 函数主要负责了用户程序执行的相关工作，它接受一个文件名后打开这个可执行文件，之后使用 `AddrSpace` 类的构造函数为其分配地址空间，之后对地址空间进行相应初始化（设置寄存器初始值、载入页表寄存器等）后调用 `machine->Run()` 执行相应用户程序。

关于类 `AddrSpace` ，其定义及相关操作位于 `code/userprog/addrspace.h` 和 `code/userprog/addrspace.cc` 中，其构造函数首先将文件头中内容加载到 `NoffHeader` 的结构体中，该结构体定义了 Nachos 目标代码格式；之后，其计算用户程序所需要空间大小；之后建立建立从用户程序地址到物理地址的翻译机制，目前使用的机制是完全的一对一的，该页表定义在 `AddrSpace` 类中。再然后其初始化物理内存空间，并将程序的 code 段和 initData 段拷贝到内存中。

`proctest.cc` 中还有一个函数 `ConsoleTest()` ，其用于控制台的输入输出测试。

#### TLB 机制和地址转换机制

`code/machine/machine.h(cc)` 中定义了各种 Nachos 硬件模拟的各种宏、结构、函数的实现。其中定义了内存大小，TLB 大小，物理页的个数和页的大小等信息，以及定义了一些异常的种类及其编号。也包括了各种指令模拟、寄存器读写、内存读写的方法。注意到在 `machine.cc` 中有一处判断了宏 `USE_TLB` ，说明 Nachos 现在的机制默认没有使用 TLB 。

在 `code/machine/translate.h(cc)` 中对地址转换机制进行了实现。

其中 `translate.h` 文件中定义了页表项和 TLB 表项类 `TranslationEntry` ，包含虚拟页号、物理页号和有效、只读等属性，负责了虚拟内存到物理内存的转换工作。

`translate.cc` 文件中实现了 Nachos 地址转换函数 `Translate()` ，将虚拟地址转换为物理地址，在出错时抛出相关错误，其中我们也能看到 Nachos 现在的处理机制不支持页表和 TLB 的共存，需要我们之后的处理。此外，该文件中也实现了读写内存的相关函数。

而 `code/userprog/exception.cc` 文件中定义了所有异常的处理函数 `ExceptionHandler()`，缺页异常和 TLB MISS 等错误的处理都在该函数中进行。此外，系统调用也在该函数中被处理。

### 2.2 Exercise 2 TLB MISS 异常处理
> 修改 code/userprog 目录下 exception.cc 中的 ExceptionHandler 函数，使得 Nachos 系统可以对 TLB 异常进行处理(TLB 异常时，Nachos 系统会抛出 PageFaultException ，详见 code/machine/machine.cc)。

首先，为了使用 TLB ，我们先在 `code/userprog/Makefile` 中添加宏定义 `USE_TLB`
```
DEFINES = -DUSER_PROGRAM -DFILESYS_NEEDED -DFILESYS_STUB -DUSE_TLB
```

之后我们注释掉 `translate.cc` 中的  `ASSERT(tlb == NULL || pageTable == NULL);` ，使得页表和 TLB 能够同时使用。这时我们能够发现，TLB MISS 时抛出 PageFaultException 异常，故我们需要在 `exception.cc` 中的 `ExceptionHandler()` 处理函数中增加对于该异常的处理。具体的 `TLBMissHandler()` ，即具体的替换算法将在 Exercise 3 中实现。

```cpp
if (which == PageFaultException) {
    if (machine->tlb == NULL) {
      printf("Page table page fault.\n");
      ASSERT(FALSE);
    } else {
      printf("TLB miss!\n");
      int BadVAddr = machine->ReadRegister(BadVAddrReg);
      TLBMissHandler(BadVAddr);
    }
    return;
  }
```

### 2.3 Exercise 3 置换算法
> 为 TLB 机制实现至少两种置换算法，通过比较不同算法的置换次数可比较算法的优劣。

在实现替换算法之前，需要首先完善 `TLBMissHandler()` 函数，将 TLB 中缺失的项从页表中拿出，再调用具体的替换算法：

```cpp
void TLBMissHandler(int BadVAddr) {
  unsigned int vpn = (unsigned) BadVAddr / PageSize;
  TranslationEntry page = machine->pageTable[vpn];
  if (!page.valid) {
    printf("True page table page fault happens!\n");
    ASSERT(FALSE);
  }
  FIFOReplace(page); // some replace algorithm
}
```

替换算法实现方面，我实现了 LRU、FIFO 和随机替换三种算法。

由于在测试时，我发现 `code/test/` 中的测试文件都不适合用于评测 TLB 的 miss rate，故我添加了一个进行数组遍历并累加的测试代码 `simple.c` ，并将其添加到了 Makefile 中，之后这部分的测试均通过 `simple` 来进行。

此外，无论哪种替换算法，我们都要评估其效果，都需要统计 TLB 的总使用次数和缺失次数。可在 `Machine` 类中添加成员 `tlbTotalCount` 和 `tlbMissCount` ，分别统计使用次数和缺失次数。在进入 `Translate()` 函数使用 TLB 时前者加 1，当未找到，发生 TLB miss 时，后者加 1，最终程序运行结束，调用 Halt 或 Exit 系统调用。我在 `exception.cc` Halt 和 Exit 的处理函数中增加对于 TLB 利用情况的输出，就能看到相应替换算法的效果。

#### FIFO

首先，我对于较为简单的 FIFO 算法进行了实现，首先尝试是否能够找到空（非有效）的 TLB 项，若有则替换，否则将所有的 TLB 项整体前移，新进入项从数组末尾进入，这样就能够让先进入 TLB 的项先被换出。

```cpp
// FIFO Replace
void FIFOReplace(TranslationEntry page) {
  printf("Using FIFO Replace Algorithm!\n");
  int replaceIdx = -1;
  for (int i = 0; i < TLBSize; i++) {
    if (machine->tlb[i].valid == FALSE) {
      replaceIdx = i;
      break;
    }
  }
  if (replaceIdx == -1) { // FIFO
    for (int i = 1; i < TLBSize; i++) {
      machine->tlb[i - 1] = machine->tlb[i];
    }
    replaceIdx = TLBSize - 1;
  }
  machine->tlb[replaceIdx] = page;
}
```

之后，我们使用 `./nachos -x ../test/simple` 进行测试，结果如下：
```
tlbTotalCount is 1211, tlbMissCount is 119, tlbMissRate is 9.826590%
```

#### LRU

要实现 LRU 算法，我们需要在 Machine 类的定义中添加数组 `tlbUseCounter` ，用于记录 TLB 的使用，当命中一个 TLB 项或换入一个新的 TLB 项时，该项的 Counter 值重置为 0 ，并让其他项的 Counter 值都加 1 。当发生 TLB miss 需要替换时，我们将 Counter 值最大的项换出。

```cpp
// LRU Replace
void LRUReplace(TranslationEntry page) {
  printf("Using LRU Replace Algorithm!\n");
  int replaceIdx = -1;
  for (int i = 0; i < TLBSize; i++) {
    machine->tlbUseCounter[i]++;
  }
  for (int i = 0; i < TLBSize; i++) {
    if (machine->tlb[i].valid == FALSE) {
      replaceIdx = i;
      break;
    }
  }
  if (replaceIdx == -1) { // LRU
    int maxm = 0;
    for (int i = 0; i < TLBSize; i++) {
      if (machine->tlbUseCounter[i] > maxm) {
        maxm = machine->tlbUseCounter[i];
        replaceIdx = i;
      }
    }
  }
  machine->tlb[replaceIdx] = page;
  machine->tlbUseCounter[replaceIdx] = 0;
}
```

测试结果如下：
```
tlbTotalCount is 1145, tlbMissCount is 75, tlbMissRate is 6.550218%
```

#### 随机替换

要使用随机替换，我们只需要使用 `machine/sysdep.cc` 中提供的接口 `Random()` 。

```cpp
// Random Replace
void RandomReplace(TranslationEntry page) {
  printf("Using Random Replace Algorithm!\n");
  int replaceIdx = -1;
  for (int i = 0; i < TLBSize; i++) {
    machine->tlbUseCounter[i]++;
  }
  for (int i = 0; i < TLBSize; i++) {
    if (machine->tlb[i].valid == FALSE) {
      replaceIdx = i;
      break;
    }
  }
  if (replaceIdx == -1) { // Random
    replaceIdx = Random() % TLBSize;
  }
  machine->tlb[replaceIdx] = page;
}
```

进行测试，测试结果为：
```
tlbTotalCount is 1162, tlbMissCount is 85, tlbMissRate is 7.314974%
```

从这三种方法的对比我们也能看出 LRU 替换算法的优越性。

### 2.4 Exercise 4 内存全局管理数据结构
> 设计并实现一个全局性的数据结构(如空闲链表、位图等)来进行内存的分配和回收，并记录当前内存的使用状态。

我尝试使用 `code/userprog/` 中提供的位图 `BitMap` 类来实现内存的全局管理。

首先，在 `code/machine/machine.h` 中添加 BitMap 类的成员 `bitmap` 并在 Machine 类的构造函数中对其进行初始化，之后添加函数 `allocMem()` 和 `freeMem()` ，它们分别调用了 BitMap 类的 `Find()` 和 `Clear()` 函数，进行空闲内存页面的分配和页表的释放。

```cpp
int Machine::allocMem() { return bitmap->Find(); }
void Machine::freeMem() {
  for (int i = 0; i < pageTableSize; i++) {
    if (pageTable[i].valid) {
      printf("Clear physical page #%d\n", pageTable[i].physicalPage);
      machine->bitmap->Clear(pageTable[i].physicalPage);
    }
  }
}
```

之后，在 `code/userprog/addrspace.cc` 的构造函数中，添加寻找空闲物理内存页的过程：

```cpp
  for (i = 0; i < numPages; i++) {
    int ppn = machine->allocMem();
    ASSERT(ppn != -1);
    printf("Allocate virtual page #%d at physical page #%d\n", i, ppn);
    pageTable[i].virtualPage = i;
    pageTable[i].physicalPage = ppn;
    pageTable[i].valid = TRUE;
    pageTable[i].use = FALSE;
    pageTable[i].dirty = FALSE;
    pageTable[i].readOnly = FALSE; // if the code segment was entirely on
                                   // a separate page, we could set its
                                   // pages to be read-only
  }
```

当用户程序结束时，会发送相应的系统调用，进入到 `exception.cc` 中的处理函数中。我们在其中调用 `freeMem()` 函数，即可在程序结束时收回相应的物理内存页。

最后，我们仍然使用自己写的 `test/simple` 程序进行测试，测试结果为：
```
Allocate virtual page #0 at physical page #0
Allocate virtual page #1 at physical page #1
Allocate virtual page #2 at physical page #2
Allocate virtual page #3 at physical page #3
Allocate virtual page #4 at physical page #4
Allocate virtual page #5 at physical page #5
Allocate virtual page #6 at physical page #6
Allocate virtual page #7 at physical page #7
Allocate virtual page #8 at physical page #8
Allocate virtual page #9 at physical page #9
Allocate virtual page #10 at physical page #10
Allocate virtual page #11 at physical page #11
...
...
Clear physical page #0
Clear physical page #1
Clear physical page #2
Clear physical page #3
Clear physical page #4
Clear physical page #5
Clear physical page #6
Clear physical page #7
Clear physical page #8
Clear physical page #9
Clear physical page #10
Clear physical page #11
Machine halting!
```

可以看到符合我们的预期。

### 2.5 Exercise 5 多线程支持
> 目前 Nachos 系统的内存中同时只能存在一个线程，我们希望打破这种限制，使得 Nachos 系统支持多个线程同时存在于内存中。

在上一个 Exercise 用 BitMap 实现内存管理时，我们已经发现，在 `code/userprog/addrspace.cc` 的构造函数中，每次会将整个物理内存空间全部清空

### 2.6 Exercise 6 缺页中断处理
> 基于 TLB 机制的异常处理和页面替换算法的实践，实现缺页中断处理(注意! TLB 机制的异常处理是将内存中已有的页面调入 TLB，而此处的缺页中断处理则是从 磁盘中调入新的页面到内存)、页面替换算法等。

### 2.7 Exercise 7 Lazy-Loading
> 我们已经知道，Nachos 系统为用户程序分配内存必须在用户程序载入内存时一次性完成，故此，系统能够运行的用户程序的大小被严格限制在 4KB 以下。请实现 Lazy-loading 的内存分配算法，使得当且仅当程序运行过程中缺页中断发生时，才会将所需 的页面从磁盘调入内存。

### 2.8 Challenge 1 
> 为线程增加挂起 SUSPENDED 状态，并在已完成的文件系统和内存管理功 能的基础之上，实现线程在“SUSPENDED”，“READY”和“BLOCKED”状态之间的切换。

### 2.9 Challenge 2 
> 多级页表的缺陷在于页表的大小与虚拟地址空间的大小成正比，为了节省物理内存在页表存储上的消耗，请在 Nachos 系统中实现倒排页表。

## 3 遇到的困难以及收获

- 在 `code/test/` 中自己写了测试文件之后无法 make 出可执行的二进制文件，应是 Nachos 的实验环境搭建出现了问题，但尝试换用 Docker、Vagrant 等各种方法后均无法解决，最终依靠同学的帮助，发现是 VirtualBox 的新版本与 Mac 系统的兼容有问题，在重装 VirtualBox 之后，问题终于得到了解决。

## 4 对课程或Lab的意见和建议

无。

## 5 参考文献

- 《操作系统》课程 PPT